import { __decorate } from "tslib";
import { Component, ChangeDetectionStrategy } from '@angular/core';
import { FieldType } from '@ngx-formly/core';
let FormlyFieldCheckbox = class FormlyFieldCheckbox extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                indeterminate: true,
                hideLabel: true,
                formCheck: 'custom',
            },
        };
    }
};
FormlyFieldCheckbox = __decorate([
    Component({
        selector: 'formly-field-checkbox',
        template: `
    <div
      [ngClass]="{
        'form-check': to.formCheck.indexOf('custom') === -1,
        'form-check-inline': to.formCheck === 'inline',
        'custom-control': to.formCheck.indexOf('custom') === 0,
        'custom-checkbox': to.formCheck === 'custom' || to.formCheck === 'custom-inline',
        'custom-control-inline': to.formCheck === 'custom-inline',
        'custom-switch': to.formCheck === 'custom-switch'
      }"
    >
      <input
        type="checkbox"
        [class.is-invalid]="showError"
        [class.form-check-input]="to.formCheck.indexOf('custom') === -1"
        [class.position-static]="to.formCheck === 'nolabel'"
        [class.custom-control-input]="to.formCheck.indexOf('custom') === 0"
        [indeterminate]="to.indeterminate && formControl.value == null"
        [formControl]="formControl"
        [formlyAttributes]="field"
      />
      <label
        *ngIf="to.formCheck !== 'nolabel'"
        [for]="id"
        [class.form-check-label]="to.formCheck.indexOf('custom') === -1"
        [class.custom-control-label]="to.formCheck.indexOf('custom') === 0"
      >
        {{ to.label }}
        <span *ngIf="to.required && to.hideRequiredMarker !== true">*</span>
      </label>
    </div>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], FormlyFieldCheckbox);
export { FormlyFieldCheckbox };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3gudHlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtZm9ybWx5L2Jvb3RzdHJhcC9jaGVja2JveC8iLCJzb3VyY2VzIjpbImNoZWNrYm94LnR5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBc0M3QyxJQUFhLG1CQUFtQixHQUFoQyxNQUFhLG1CQUFvQixTQUFRLFNBQVM7SUFBbEQ7O1FBQ0UsbUJBQWMsR0FBRztZQUNmLGVBQWUsRUFBRTtnQkFDZixhQUFhLEVBQUUsSUFBSTtnQkFDbkIsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsU0FBUyxFQUFFLFFBQVE7YUFDcEI7U0FDRixDQUFDO0lBQ0osQ0FBQztDQUFBLENBQUE7QUFSWSxtQkFBbUI7SUFwQy9CLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSx1QkFBdUI7UUFDakMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0JUO1FBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07S0FDaEQsQ0FBQztHQUNXLG1CQUFtQixDQVEvQjtTQVJZLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpZWxkVHlwZSB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtbHktZmllbGQtY2hlY2tib3gnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXZcbiAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgJ2Zvcm0tY2hlY2snOiB0by5mb3JtQ2hlY2suaW5kZXhPZignY3VzdG9tJykgPT09IC0xLFxuICAgICAgICAnZm9ybS1jaGVjay1pbmxpbmUnOiB0by5mb3JtQ2hlY2sgPT09ICdpbmxpbmUnLFxuICAgICAgICAnY3VzdG9tLWNvbnRyb2wnOiB0by5mb3JtQ2hlY2suaW5kZXhPZignY3VzdG9tJykgPT09IDAsXG4gICAgICAgICdjdXN0b20tY2hlY2tib3gnOiB0by5mb3JtQ2hlY2sgPT09ICdjdXN0b20nIHx8IHRvLmZvcm1DaGVjayA9PT0gJ2N1c3RvbS1pbmxpbmUnLFxuICAgICAgICAnY3VzdG9tLWNvbnRyb2wtaW5saW5lJzogdG8uZm9ybUNoZWNrID09PSAnY3VzdG9tLWlubGluZScsXG4gICAgICAgICdjdXN0b20tc3dpdGNoJzogdG8uZm9ybUNoZWNrID09PSAnY3VzdG9tLXN3aXRjaCdcbiAgICAgIH1cIlxuICAgID5cbiAgICAgIDxpbnB1dFxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBbY2xhc3MuaXMtaW52YWxpZF09XCJzaG93RXJyb3JcIlxuICAgICAgICBbY2xhc3MuZm9ybS1jaGVjay1pbnB1dF09XCJ0by5mb3JtQ2hlY2suaW5kZXhPZignY3VzdG9tJykgPT09IC0xXCJcbiAgICAgICAgW2NsYXNzLnBvc2l0aW9uLXN0YXRpY109XCJ0by5mb3JtQ2hlY2sgPT09ICdub2xhYmVsJ1wiXG4gICAgICAgIFtjbGFzcy5jdXN0b20tY29udHJvbC1pbnB1dF09XCJ0by5mb3JtQ2hlY2suaW5kZXhPZignY3VzdG9tJykgPT09IDBcIlxuICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJ0by5pbmRldGVybWluYXRlICYmIGZvcm1Db250cm9sLnZhbHVlID09IG51bGxcIlxuICAgICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIlxuICAgICAgICBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiXG4gICAgICAvPlxuICAgICAgPGxhYmVsXG4gICAgICAgICpuZ0lmPVwidG8uZm9ybUNoZWNrICE9PSAnbm9sYWJlbCdcIlxuICAgICAgICBbZm9yXT1cImlkXCJcbiAgICAgICAgW2NsYXNzLmZvcm0tY2hlY2stbGFiZWxdPVwidG8uZm9ybUNoZWNrLmluZGV4T2YoJ2N1c3RvbScpID09PSAtMVwiXG4gICAgICAgIFtjbGFzcy5jdXN0b20tY29udHJvbC1sYWJlbF09XCJ0by5mb3JtQ2hlY2suaW5kZXhPZignY3VzdG9tJykgPT09IDBcIlxuICAgICAgPlxuICAgICAgICB7eyB0by5sYWJlbCB9fVxuICAgICAgICA8c3BhbiAqbmdJZj1cInRvLnJlcXVpcmVkICYmIHRvLmhpZGVSZXF1aXJlZE1hcmtlciAhPT0gdHJ1ZVwiPio8L3NwYW4+XG4gICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybWx5RmllbGRDaGVja2JveCBleHRlbmRzIEZpZWxkVHlwZSB7XG4gIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHRlbXBsYXRlT3B0aW9uczoge1xuICAgICAgaW5kZXRlcm1pbmF0ZTogdHJ1ZSxcbiAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgIGZvcm1DaGVjazogJ2N1c3RvbScsIC8vICdjdXN0b20nIHwgJ2N1c3RvbS1pbmxpbmUnIHwgJ2N1c3RvbS1zd2l0Y2gnIHwgJ3N0YWNrZWQnIHwgJ2lubGluZScgfCAnbm9sYWJlbCdcbiAgICB9LFxuICB9O1xufVxuIl19